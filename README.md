# MWC128 - Multiply With Carry Рseudo-Random Number Generators  (PRNG)

* __Анатолий М. Георгиевский, ИТМО__

Алгоритмы данной группы используются для генерации последовательности псеводслучайных чисел с однородным распределением.

Методы пригодны для параллельной реализации в задачах моделирования физических процессов. Основной показатель применимости методов для параллельных (высокопроизводительных) вычислений - это возможность получения последовательности с заданным отступом для распределения задачи между вычислительными ядрами, чтобы результат параллельной обработки давал в точности такой же результат, как и последовательное вычисление. 

В данном проекте даются методы вычисления отсупов основанные на модульной арифметике большой разрядности (multi-prcision, см. [mp.c](mp.c)). 

## Теория

Последовательность MWC — это последовательность пар $x_{n},c_{n}$, определяемых
```math
x_{n}=(ax_{n-1}+c_{n-1})\,{\bmod {\,}}b,\ c_{n}=\left\lfloor {\frac {ax_{n-1}+c_{n-1}}{b}}\right\rfloor
```

Последовательность с запаздыванием $r$ является обобщением последовательности с запаздыванием на 1, 
позволяющим использовать более длинные периоды [2]. Последовательность MWC с запаздыванием $r$ — это последовательность пар $x_{n},c_{n}$ (для $n>r$), определяемых
```math
x_{n}=(ax_{n-r}+c_{n-1})\,{\bmod {\,}}b,\ c_{n}=\left\lfloor {\frac {ax_{n-r}+c_{n-1}}{b}}\right\rfloor
```


Утверждение #1. $(x+c b)A \bmod (Ab - 1) \equiv xA + c$

Доказательство:
$(x+cb)A  = xA + c(Ab-1) + c = xA + c(Ab-1) + c, \bmod (Ab - 1)$
Средняя часть обращается в ноль, потому что кратно модулю. 

Утверждение #2. $Ab \bmod (Ab - 1) = 1$. $А$ - обратное число для $b$

> Если $p = ab^r − 1$ является простым числом, то малая теорема Ферма гарантирует, что порядок любого элемента должен делиться на $p − 1 = ab^r − 2$, поэтому один из способов обеспечить большой порядок — выбрать $a$ так, 
чтобы $p$ было «безопасным простым числом», то есть p и $(p − 1)/2 = ab^r/2 − 1$ были простыми числами. В таком случае для $b = 2^{32}$ и $r = 1$ период будет равен $ab^r/2 − 1$, что приближается к $2^{31}$, что на практике может быть приемлемо большим подмножеством числа возможных 32-битных пар $(x, c)$.
-- перевод с [Wiki](https://en.wikipedia.org/wiki/Multiply-with-carry_pseudorandom_number_generator)

## MWC64x

Алгоритм разработан благодяря онлайн публикации [MWC64x](https://cas.ee.ic.ac.uk/people/dt10/research/rngs-gpu-mwc64x.html). К алгоритму приписал модульную арифметику с вычислением отступов для многопотокового вычисления. 

## MWC32

Практическое решение задачи поиска константы для 32 битных чисел дано двумя методами. Оба метода реализованы путем расчета *всей* последовательности.
1. Путем тестирования множества простых чисел в диапазоне 512-1023
2. Путем последовательного перебора чисел в диапазоне [0..1023] (дата майниг)

Критерием выбора константы $A$ для генератора является длина пероида повторения последовательности, которая дается формулой $ab^r/2 − 2$.

Тестом на простоту Ферма является утверждение $x^{p-1} = 1$ для любого x.
Для чисел вида $A\cdot 2^{n} -1$ тестом простоты является LLR([Тест Люка — Лемера — Ризеля](https://en.wikipedia.org/wiki/Lucas%E2%80%93Lehmer%E2%80%93Riesel_test)), as a special case of the Morrison test. Реализация теста,см. проект [PRST by Pavel Atnashev](https://github.com/patnashev/prst)

Другой набор тестов включает однородность и возможность сжатия (муаровый узор на "салфетках"). Для исследования однородности использовалось построение изображений по большому числу циклов. Тесты наглядно показывают отсуствие водяных знаков при использовании младших 16-20 бит. Тест при числе проходов 0x7F (8 бит, grayscale):

![тест на однородность заполнения](test.png)

Для повышения однородности следует использовать только четные значения или только нечетные вызовы функции. 
Для A=0xFE94 при большом колчиестве циклов 0x7FFF, Формат файла (Grayscale 16 бит):
![тест на однородность заполнения](0xFE94.png)

"Безопасным простым" является P=0xfe9fffff (A=FEA0) с периодом повтора 0x7f4ffffe.
Генератор последовательности:
```c
uint32_t next( uint32_t* state, const uint32_t A)
{
	uint32_t x = *state;
	*state = A*(uint16_t)(x) + (x>>16);
    return x;
}
```
Ниже привожу таблицу всех простых чисел $P= (A<<16)-1$ c максимальным периодом повтора.
```
A=FFEA i=7ff4fffe ( 21), P mod 24 =23, A mod 3 =0
A=FFD7 i=7feb7ffe ( 40), P mod 24 = 7, A mod 3 =2
A=FFBD i=7fde7ffe ( 66), P mod 24 =23, A mod 3 =0
A=FFA8 i=7fd3fffe ( 87), P mod 24 =23, A mod 3 =0
A=FF9B i=7fcd7ffe (100), P mod 24 = 7, A mod 3 =2
A=FF81 i=7fc07ffe (126), P mod 24 =23, A mod 3 =0
A=FF80 i=7fbffffe (127), P mod 24 = 7, A mod 3 =2
A=FF7B i=7fbd7ffe (132), P mod 24 =23, A mod 3 =0
A=FF75 i=7fba7ffe (138), P mod 24 =23, A mod 3 =0
A=FF48 i=7fa3fffe (183), P mod 24 =23, A mod 3 =0
A=FF3F i=7f9f7ffe (192), P mod 24 =23, A mod 3 =0
A=FF3C i=7f9dfffe (195), P mod 24 =23, A mod 3 =0
A=FF2C i=7f95fffe (211), P mod 24 = 7, A mod 3 =2
A=FF09 i=7f847ffe (246), P mod 24 =23, A mod 3 =0
A=FF03 i=7f817ffe (252), P mod 24 =23, A mod 3 =0
A=FF00 i=7f7ffffe (255), P mod 24 =23, A mod 3 =0
A=FEEB i=7f757ffe (276), P mod 24 =23, A mod 3 =0
A=FEE4 i=7f71fffe (283), P mod 24 = 7, A mod 3 =2
A=FEA8 i=7f53fffe (343), P mod 24 = 7, A mod 3 =2
A=FEA5 i=7f527ffe (346), P mod 24 = 7, A mod 3 =2
A=FEA0 i=7f4ffffe (351), P mod 24 =23, A mod 3 =0
A=FE94 i=7f49fffe (363), P mod 24 =23, A mod 3 =0
A=FE8B i=7f457ffe (372), P mod 24 =23, A mod 3 =0
A=FE72 i=7f38fffe (397), P mod 24 = 7, A mod 3 =2
A=FE4E i=7f26fffe (433), P mod 24 = 7, A mod 3 =2
A=FE30 i=7f17fffe (463), P mod 24 = 7, A mod 3 =2
A=FE22 i=7f10fffe (477), P mod 24 =23, A mod 3 =0
A=FE15 i=7f0a7ffe (490), P mod 24 = 7, A mod 3 =2
A=FE04 i=7f01fffe (507), P mod 24 =23, A mod 3 =0
```
