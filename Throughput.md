# Тест пропускной способности ГПСЧ

В данном разделе мы показываем сравнение пропускной способности алгоритмов генерации ГПСЧ. Предполагается что метод выполняется в цикле и генерирует поток данных. Пропускную способность можно измерить в тактах генератора. Здесь мы представляем методику тестирования при оптимизации циклов и метод измерения пропускной способности в приложении. 

- [Тест пропускной способности ГПСЧ](#тест-пропускной-способности-гпсч)
  - [Методика оптимизации](#методика-оптимизации)
  - [Методика тестирования Throughput](#методика-тестирования-throughput)
  - [Результаты тестирования](#результаты-тестирования)




## Методика оптимизации

Метод тестирования - LLVM-MCA анализатор машинного кода. Методика тестирования - преобразование в ассемблер. Анализ выполняется с учетом длины конвейера разбора команд и вероятности загрузки вычислительных блоков и каналов памяти для выбранной архитектуры процессора. Тестирование выполнено под процессор AMD Zen4 с архитектурой x86_64. Аналогично могут быть выполнены сравнения под архитектуру AArch64.

Утилита LLVM-MCA составляет отчет загрузки процессорных блоков целевой архитектуры и пропускной способности операции в цикле. Особенность такого подхода - на первом цикле происходит декодирование команд. Наибольшая пропускная способность достигается на последующих итерациях за счет исполнения команд с нарушением порядка следования. В современных процессорах от 4 до 6 команд могу быть декодированы параллельно и одновременно завершены, конвейер команд распределяет микрокоманды по исполнительным блокам.

Реализация MWC64
```c
#define MWC_A0 0xfffeb81bULL
uint64_t mwc64_next( uint64_t* state)
{
	uint64_t x = *state;
	*state = MWC_A0*(uint32_t)(x) + (x>>32);
    return x;
}
```

```sh
$ gcc -march=native -O3 -S -o test.s mwc64.c
```
В цикле это четыре инструкции процессора
```asm
        imulq   %r8, %rax
        movq    %rdx, %r8
        shrq    $32, %r8
        addq    %r8, %rax
```
Тест пропускной способности:
```sh
$ llvm-mca --mcpu=znver4 -timeline test.s

IPC:               4.58
Block RThroughput: 1.0

[7,0]     .    . D=eE---R.   .   movl   $4294883355, %r8d
[7,1]     .    . D------R.   .   movl   %edx, %eax
[7,2]     .    . D==eeeER.   .   imulq  %r8, %rax
[7,3]     .    . D------R.   .   movq   %rdx, %r8
[7,4]     .    . D==eE--R.   .   shrq   $32, %r8
[7,5]     .    . D=====eER   .   addq   %r8, %rax

```
Результат: Пропускная способность (RThroughput) = 1 такт на цикл, на новое состояние. IPC - число инструкций на цикл очень высокий показатель. 

В листинге отчета используется временная диаграмма с условными обозначениями: D - декодирование команды, e- исполнение, R- запись результата в регистр. Вычислительные блоки могут работать в конвейерном режиме, начинать исполнение инструкции до завершения предыдущей и некоторые операции могут распределены между несколькими блоками, исполняться параллельно. Предполагается что читатель хотя бы приблизительно знаком с принципами работы ядра процессора и мнемониками ассемблера. Для специалистов по оптимизации кода, это должны быть знакомые и понятные концепции. От себя скажу, что каждый раз когда я занимаюсь отладкой и оптимизацией критических алгоритмов я обращаюсь к огромному справочнику Intel по системам команд и разбираюсь в процессорных архитектурах. Системы команд Intel x86 и ARM Aarch64 мне знакомы. 


Для сравнения приведем код Xoroshiro64


## Методика тестирования Throughput

Предлагается метод: мы создаем специальный тест, куда помещается inline-функция генератора. Тест содержит цикл заполнения буфера при последовательной или параллельной генерации.Замеряется время в тактах процессора на заполнение объема порядка 64MB. Измерение задержек основано на использовании специальных инструкций. Перед блоком рекомендуется выполнить FENCE - что гарантирует очистку конвейера команд и делает бенчмарк воспроизводимым. 

```c
#include <x86intrin.h>

static inline uint64_t rdtscp_start() {
    unsigned dummy;
    __builtin_ia32_lfence();
    return __rdtscp(&dummy);
}

static inline uint64_t rdtscp_end() {
    unsigned dummy;
    uint64_t t = __rdtscp(&dummy);
    __builtin_ia32_lfence();
    return t;
}

// использование:
uint64_t t0 = rdtscp_start();
#pragma GCC unroll 16
for(int i=0; i<samples; i++){
    /* тестируемый код */
}
uint64_t t1 = rdtscp_end();
uint64_t cycles = t1 - t0;
printf("%.1f cps, \n", cycles/samples, );
```

Вывод результатов - 
1. число тактов на семпл
2. число байт в секунду, 
3. число семплов в секунду. 
   
При тестировании различаются 32 бит/семпл, 64 бит/семпл, и вектора 64x4 бит при параллельном вычислении сегментов с использованием `jump()`. 
Для оптимизации циклов применяется разметка LLVM-MCA.

## Результаты тестирования

Результаты тестов LLVM-MCA: mwc128.txt, mwc192.txt, mwc256.txt, xoroshiro128.txt

| Генератор | CPS | семпл/сек | байт/сек |
|-----------|-----|-----------|----------|
|||||