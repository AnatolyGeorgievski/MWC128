# Хэш функция на базе генератора случайных чисел

 * _Анатолий М. Георгиевский_ , ИТМО, 2026 (https://github.com/AnatolyGeorgievski)
 * _ĀĿΞX_ (https://github.com/Alex20129), -- обсуждение принципов построения mwc-хэш и тестирование 

> Представляем метод синтеза некриптографической хэш-функции на алгоритмах MWC128.

Известно множество некриптографических функций, которые могут быть использованы для индексации баз данных и проверки контрольных сумм массивов данных. К таким функция предъявляются требования - низкая вероятность коллизий. Традиционно эта ниша занята алгоритмами CRC64, однако линейное преобразование LCG или CRC не избавляет от коллизий. В сетевых протоколах и архиваторах используются различные некриптографические функции, среди которых выделяется xxHash64 (Yann Collet). Нас интересует разработка быстрой хэш-функции для работы потоке данных и с большими массивами данных, такими как тензорные данные языковых моделей. Алгоритм вычисления хэш должен допускать возможность считать параллельно с разбивкой данных на сегменты и векторизовать вычисления.

Современные хэш-функции строятся по принципу SPONGE-SQUEEZE: состоят из цикла впитывания данных и отжимания "губки". Мы предлагаем архитектуру хэш функции построенную на обратимых линейных и нелинейных операциях: 

1. Линейный генератор с возможностью выполнять skip/jump и merge на потоке данных.
2. Функция пермутации-миксер выходных данных.

Обратимость операций и линейный генератор в основе обеспечивают возможность выполнения операций над потоками данных:
1. `next(s)` - генерация следующего состояния.
2. `prev(s)` - генерация предыдущего состояния без использования контрольных точек, на основе текущего состояния, обратный шаг генератора.
3. `skip(s,n)` - пропуск шагов генератора, n-элементов данных в потоке.
4. `merge(s1, s2, n)` - слияние хешей от двух сегментов, с учетом дистанции между  сегментами
5. `jump(s, m)` пропуск сегмента на основе константы, например $2^m$, поддерживается ограниченных набор сдвиговых констант.
6. `mix(x)` функция смешивания на выходе генератора
7. `unmix(x)` функция обратная миксеру

Всеми этими качествами обладает генератор на основе CRC или LFSR. Полным аналогом в модульной арифметике является MWC генератор, который представляет собой редуцирование после сдвига, аналогично шагу CRC алгоритма. 

Тестирование хэш-функций выполняется в пакете [SMHasher](https://github.com/aappleby/smhasher). Тесты ориентированы на выявление слабых бит в хэше и поиск коллизий.

В данной работе мы ссылаемся на опыт разработки LXM генератора [4], где авторы использовали множество типовых миксеров для придания функции генератора ГПСЧ необходимого качества, для прохождения тестов без коллизий.

В ходе разработки алгоритма мы повторили результаты [4] с использованием генератора `Xoroshiro128p` И миксера выходных значений предложенного авторами в работе. Кроме того протестировали ряд других миксеров. Исходный код подготовлен для теста SMHasher см. [xoroshiro-hash](test/xoshiro_hash.c). Для сравнения реализовали собственную версию функции [xxHash64](test/xxh64.c) переносимую и с явной векторизацией. 

Мы видим две цели, получить качественный алгоритм PRNG-hash и разработать модель обратимого, дописываемого хэша. Первая цель включает подбор параметров и выходных миксеров для достижения высоких показателей в тестах. Вторая цель создание математического объекта способного заменить CRC в задачах контроля целостности и кэширования больших объемов данных, таких как тензоры языковых моделей. 

**Алгоритм MWC128-hash**

```c
uint64_t mwc128_hash(const uint8_t *data, uint64_t len, uint64_t seed0) {
	uint128_t h;
	uint64_t* s = (uint64_t*)&h;
	for (int i=0;i<2;i++)
		s[i] = unmix(seed+=IV);
	for (int i=0; i<len>>3; i++){
		h+=*(uint64_t*)data; data+=8;
		h = (uint64_t )h*A1 + (h>>64); // итерация MWC128
	}
	if (len&7) {
		int r = len&7;// reminder
		uint64_t d = 0;
		memcpy(&d, data, r); data+=r;
		h+= (d);
		h = ((uint64_t )h<<(64-r*8))*A1 + (h>>(r*8));
	}
	return mix(h^(h>>64));
}
```
Параметры алгоритма: 
* `A1` - параметр генератора MWC128, где $P=A_1\cdot 2^{64} -1$ простое число.
* `IV` - вектор инициализации хэш

В составе алгоритма использован миксер Doug Lea's. Это не самый сильный миксер, но самый простой и оптимально подошел к нашей задаче. 
```c
// Doug Lea's MXMX- mixing function
static inline uint64_t mix_lea(uint64_t h) {
  h ^= h >> 32;
  h *= 0xdaba0b6eb09322e3ull;
  h ^= h >> 32;
  h *= 0xdaba0b6eb09322e3ull;
  h ^= h >> 32;
  return h;
}
```
Ниже мы приводим множество миксеров, с которыми можно комбинировать выход функции генератора. Миксеры можно выбирать разной сложности в архитектуре XMXMX или более простые: X, MX, XMX. Прохождение тестов SMHasher обеспечивают миксеры XMXMX. 

Выбор констант генератора должен давать равномерное распределение бит в тестах SMHasher и TestU01. Среди тестов TestU01 мы выделяем тест  `Linear-complexity` c существенно большим периодом. Каждый бит тестируется отдельно. 
```c
for (int i=32; i-->0;){
	scomp_LinearComp(&gen, NULL, 1, 400000, i, 1);
}
```

**Алгоритм PRNG-hash**

Алгоритм построен на генераторе Xoroshiro128, как в работе [4], LXM. Применяется рандомизация и миксер выходных значений. В качестве миксера выбрана функция `mix_lea()`, Doug Lea's mixing function. 
Для построения хэш функции использован генератор `Xoroshiro128+`, выходным значением генератора является `plus` скрамблер от внутреннего состояния.
```c
uint64_t xoroshiro_hash(const uint8_t *data, uint64_t len, uint64_t seed) {
	uint64_t s[STATE_SZ];
	for (int i=0; i<STATE_SZ; i++)
		s[i] = unmix(seed+=IV);
	for (int i=0; i<len; i++) {
		s[0] ^= *data++;
		next(s);
	}
 	return mix(s);
}
```

Функция миксера, как и функция генератора - обратима. Это свойство может быть использовано при контроле целостности в операции дописывания данных в конец файла.

**Генераторы xorshift**

1. $x ←  x \oplus (x \gg a)$
3. $x ←  x \oplus (x \ll b)$
5. $x ←  x \oplus (x \gg c)$

-- Классический генератор, в котором можно комбинировать левые и правые сдвиги (a,b,c). 

Таблица вариантов алгоритма
| Вариант | C-код (порядок операций)                            |
|---------|-----------------------------------------------------|
| A₀      | `x ^= x << a; x ^= x >> b; x ^= x << c;`            |
| A₁      | `x ^= x << c; x ^= x << b; x ^= x >> c;`            |
| A₂      | `x ^= x << c; x ^= x >> b; x ^= x << a;`            |
| A₃      | `x ^= x >> c; x ^= x << b; x ^= x >> a;`            |
| A₄      | `x ^= x << a; x ^= x << c; x ^= x >> b;`            |
| A₅      | `x ^= x >> a; x ^= x << c; x ^= x << b;`            |
| A₆      | `x ^= x >> b; x ^= x << a; x ^= x << c;`            |
| A₇      | `x ^= x << b; x ^= x >> a; x ^= x >> c;`            |

Операции 

[1402.6246] An experimental exploration of Marsaglia's xorshift generators, scrambled
Sebastiano Vigna\
ACM Transactions on Mathematical Software, Volume 42, Issue 4, Article No. 30 (2016)
PDF: https://vigna.di.unimi.it/ftp/papers/xorshift.pdf, arXiv:1402.6246

[1404.0390] Further scramblings of Marsaglia's xorshift generators, Sebastiano Vigna
arXiv:1404.0390 (2014)\
PDF: https://vigna.di.unimi.it/ftp/papers/xorshiftplus.pdf

Варианты алгоритма с задержкой

1. $t = x_1 ⊕ (x_1 H_1 a)$
2. $t = t ⊕ (t H_2 b)$
3. $x_i = x_{i+1}; \quad i = 1, 2,... r − 1$
4. $x_r = (x_r ⊕ (x_r H_3 c)) ⊕ t$

-- Обобщенная модель генератора xorshift с задержкой, где $H_1,H_2,H_3$ операции сдвига влево или вправо. Для увеличения состояния используется перестановка элементов вектора состояния. 
[111] G. Marsaglia. Xorshift RNGs. Journal of Statistical Software, 8(14):1-6, 2003. 

<!--
| 1, 3,10| 1, 5,16| 1, 5,19| 1, 9,29| 1,11, 6| 1,11,16| 1,19, 3| 1,21,20| 1,27,27|
| 2, 5,15| 2, 5,21| 2, 7, 7| 2, 7, 9| 2, 7,25| 2, 9,15| 2,15,17| 2,15,25| 2,21, 9|
| 3, 1,14| 3, 3,26| 3, 3,28| 3, 3,29| 3, 5,20| 3, 5,22| 3, 5,25| 3, 7,29| 3,13, 7|
| 3,23,25| 3,25,24| 3,27,11| 4, 3,17| 4, 3,27| 4, 5,15| 5, 3,21| 5, 7,22| 5, 9,7 |
| 5, 9,28| 5, 9,31| 5,13, 6| 5,15,17| 5,17,13| 5,21,12| 5,27, 8| 5,27,21| 5,27,25|
| 5,27,28| 6, 1,11| 6, 3,17| 6,17, 9| 6,21, 7| 6,21,13| 7, 1, 9| 7, 1,18| 7, 1,25|
| 7,13,25| 7,17,21| 7,25,12| 7,25,20| 8, 7,23| 8,9,23 | 9, 5,1 | 9, 5,25| 9,11,19|
| 9,21,16|10, 9,21|10, 9,25|11, 7,12|11, 7,16|11,17,13|11,21,13|12, 9,23|13, 3,17|
|13, 3,27|13, 5,19|13,17,15|14, 1,15|14,13,15|15, 1,29|17,15,20|17,15,23|17,15,26|

| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|---|---|---|---|---|---|---|---|---|
| 1, 1,54| 1, 1,55| 1, 3,45| 1, 7, 9| 1, 7,44| 1, 7,46| 1, 9,50| 1,11,35| 1,11,50|
| 1,13,45| 1,15, 4| 1,15,63| 1,19, 6| 1,19,16| 1,23,14| 1,23,29| 1,29,34| 1,35, 5|
| 1,35,11| 1,35,34| 1,45,37| 1,51,13| 1,53, 3| 1,59,14| 2,13,23| 2,31,51| 2,31,53|
| 2,43,27| 2,47,49| 3, 1,11| 3, 5,21| 3,13,59| 3,21,31| 3,25,20| 3,25,31| 3,25,56|
| 3,29,40| 3,29,47| 3,29,49| 3,35,14| 3,37,17| 3,43, 4| 3,43, 6| 3,43,11| 3,51,16|
| 3,53, 7| 3,61,17| 3,61,26| 4, 7,19| 4, 9,13| 4,15,51| 4,15,53| 4,29,45| 4,29,49|
| 4,31,33| 4,35,15| 4,35,21| 4,37,11| 4,37,21| 4,41,19| 4,41,45| 4,43,21| 4,43,31|
| 4,53, 7| 5, 9,23| 5,11,54| 5,15,27| 5,17,11| 5,23,36| 5,33,29| 5,41,20| 5,45,16|
| 5,47,23| 5,53,20| 5,59,33| 5,59,35| 5,59,63| 6, 1,17| 6, 3,49| 6,17,47| 6,23,27|
| 6,27, 7| 6,43,21| 6,49,29| 6,55,17| 7, 5,41| 7, 5,47| 7, 5,55| 7, 7,20| 7, 9,38|
| 7,11,10| 7,11,35| 7,13,58| 7,19,17| 7,19,54| 7,23, 8| 7,25,58| 7,27,59| 7,33, 8|
| 7,41,40| 7,43,28| 7,51,24| 7,57,12| 8, 5,59| 8, 9,25| 8,13,25| 8,13,61| 8,15,21|
| 8,25,59| 8,29,19| 8,31,17| 8,37,21| 8,51,21| 9, 1,27| 9, 5,36| 9, 5,43| 9, 7,18|
| 9,19,18| 9,21,11| 9,21,20| 9,21,40| 9,23,57| 9,27,10| 9,29,12| 9,29,37| 9,37,31|
| 9,41,45|10, 7,33|10,27,59|10,53,13|11, 5,32|11, 5,34|11, 5,43|11, 5,45|11, 9,14|
|11, 9,34|11,13,40|11,15,37|11,23,42|11,23,56|11,25,48|11,27,26|11,29,14|11,31,18|
|11,53,23|12, 1,31|12, 3,13|12, 3,49|12, 7,13|12,11,47|12,25,27|12,39,49|12,43,19|
|13, 3,40|13, 3,53|13, 7,17|13, 9,15|13, 9,50|13,13,19|13,17,43|13,19,28|13,19,47|
|13,21,18|13,21,49|13,29,35|13,35,30|13,35,38|13,47,23|13,51,21|14,13,17|14,15,19|
|14,23,33|14,31,45|14,47,15|15, 1,19|15, 5,37|15,13,28|15,13,52|15,17,27|15,19,63|
|15,21,46|15,23,23|15,45,17|15,47,16|15,49,26|16, 5,17|16, 7,39|16,11,19|16,11,27|
|16,13,55|16,21,35|16,25,43|16,27,53|16,47,17|17,15,58|17,23,29|17,23,51|17,23,52|
|17,27,22|17,45,22|17,47,28|17,47,29|17,47,54|18, 1,25|18, 3,43|18,19,19|18,25,21|
|18,41,23|19, 7,36|19, 7,55|19,13,37|19,15,46|19,21,52|19,25,20|19,41,21|19,43,27|
|20, 1,31|20, 5,29|21, 1,27|21, 9,29|21,13,52|21,15,28|21,15,29|21,17,24|21,17,30|
|21,17,48|21,21,32|21,21,34|21,21,37|21,21,38|21,21,40|21,21,41|21,21,43|21,41,23|
|22, 3,39|23, 9,38|23, 9,48|23, 9,57|23,13,38|23,13,58|23,13,61|23,17,25|23,17,54|
|23,17,56|23,17,62|23,41,34|23,41,51|24, 9,35|24,11,29|24,25,25|24,31,35|25, 7,46|
|25, 7,49|25, 9,39|25,11,57|25,13,29|25,13,39|25,13,62|25,15,47|25,21,44|25,27,27|
|25,27,53|25,33,36|25,39,54|28, 9,55|28,11,53|29,27,37|31, 1,51|31,25,37|31,27,35|
|33,31,43|33,31,55|43,21,46|49,15,61|55, 9,56|

Пример генератора xoroshiro из статьи:
```c
uint64_t xorshitf_next(){
	static uint64_t x=88172645463325252LL;
	x^=(x<<13); 
	x^=(x>>7); 
	x^=(x<<17);
	return x;
}
```
В контексте обратимости генератора с задержкой следует рассматривать обратную матрицу преобразования. 

**Генераторы xoshiro**

1. $t = x_1$
3. $\mathbf{x} = \mathbf{x} \oplus shuffle(\mathbf{x}, mm)$ -- векторная операция $\oplus$ и  перестановка {3,2,0,1}.
4. $x_{r-1} = x_{r-1} \oplus (t \ll a)$
5. $x_r = x_r \ggg b$
-->

**Генераторы xoroshiro128**
```c
static inline void xoroshiro128_next(uint64_t* s) {
	uint64_t s0 = s[0];
	uint64_t s1 = s[1];
	s1 ^= s0;
	s0 = rotl(s0, A);
	s[0] = s0 ^ s1 ^ (s1 << B);
	s[1] = rotl(s1, C);
}
```
Известные константы сдвигов [A,B,C]: . 

В исходном коде определены три функции xoroshiro с состоянием 128 бит. 


**Генераторы PRNG на базе ARX-структур**

За основу берется четверть раунда ChaCha20 или Salsa20 минимальное число раундов 8.
```c
static inline void half_qr(uint32_t s[4], int rot) {
    uint32_t a = s[0], b = s[1], c = s[2], d = s[3];

    a += b; d = ROTL32(d^a, 16 + rot);
    c += d; b = ROTL32(b^c, 12 + rot);

    // перестановка — один из лучших вариантов {3,2,0,1}
    uint32_t t[4] = {a, b, c, d};
    s[0] = t[1];    // b
    s[1] = t[3];    // d
    s[2] = t[0];    // a
    s[3] = t[2];    // c
}
```

**Mixer parameters**

Отправной точкой исследования является вариант финального миксера из функции `MurmurHash3`. Кроме того, в составе разных хэш-функций мы нашли много вариантов миксера со структурой XMXMX:

1. $x ←  x \oplus (x \gg a)$
2. $x ←  x \cdot Prime_1$
3. $x ←  x \oplus (x \gg b)$
4. $x ←  x \cdot Prime_2$
5. $x ←  x \oplus (x \gg c)$

Подобный миксер `Doug Lea's` использован в работе [4], `SplitMix64`  предлагается авторами в качестве рандомизатора SEED при инициализации `Xoroshiro128` и генераторов с большой разрядностью состояния. `Avalanche` миксер заимствован из функции `xxHash64`. Сложность миксера может варьироваться от одной итерации Mul-Xor-shift до двух-трех. Мы рассматриваем миксеры со структурой: MX, XMX, MXMX, XMXMX.

MurmurHash3 64-bit avalanche mixer представлен в проекте SMHasher, Appleby 2016. 

| Mixer	      | a | Prime1 | b | Prime2 | c |
|-------------|---|--------|---|--------|---|
| MurmurHash3 |33 |0xff51afd7ed558ccd |33 |0xc4ceb9fe1a85ec53	|33 |
| Doug Lea's  |32 |0xdaba0b6eb09322e3 |32 |0xdaba0b6eb09322e3	|32 |
| SplitMix64  |30 |0xbf58476d1ce4e5b9 |27 |0x94d049bb133111eb   |31 |
| Avalanche   |33 |0xC2B2AE3D27D4EB4F |29 |0x165667B19E3779F9   |32 |

[David Stafford's improved mixing functions](http://zimbry.blogspot.com/2011/09/better-bit-mixing-improving-on.html) опубликованы в блоге автора.

Теблица David Stafford's Mixer 
| Mixer	| a | Prime1 | b | Prime2 | c | max ord |
|-------|---|--------|---|--------|---|-----|
|Mix01	|31	|0x7fb5d329728ea185	|27	|0x81dadef4bc2dd44d	|33 | ★★ |
|Mix02	|33	|0x64dd81482cbd31d7	|31	|0xe36aa5c613612997	|31 | ☆☆ |
|Mix03	|31	|0x99bcf6822b23ca35	|30	|0x14020a57acced8b7	|33 | ★☆ | 
|Mix04	|33	|0x62a9d9ed799705f5	|28	|0xcb24d0a5c88c35b3	|32 | ★★ | 
|Mix05	|31	|0x79c135c1674b9add	|29	|0x54c77c86f6913e45	|30 | ★★ | 
|Mix06	|31	|0x69b0bc90bd9a8c49	|27	|0x3d5e661a2a77868d	|30 | ☆★ | 
|Mix07	|30	|0x16a6ac37883af045	|26	|0xcc9c31a4274686a5	|32 | ★★ | 
|Mix08	|30	|0x294aa62849912f0b	|28	|0x0a9ba9c8a5b15117	|31 | ★☆ | 
|Mix09	|32	|0x4cd6944c5cc20b6d	|29	|0xfc12c5b19d3259e9	|32 | ★☆ | 
|Mix10	|30	|0xe4c7e495f4c683f5	|32	|0xfda871baea35a293	|33 | ★★ | 
|Mix11	|27	|0x97d461a8b11570d9	|28	|0x02271eb7c6c4cd6b	|32 | ☆★ |
|Mix12	|29	|0x3cd0eb9d47532dfb	|26	|0x63660277528772bb	|33 | ★★ |
|Mix13	|30	|0xbf58476d1ce4e5b9	|27	|0x94d049bb133111eb	|31 | ☆★ |
|Mix14	|30	|0x4be98134a5976fd3	|29	|0x3bc0993a5ad19a13	|31 | ★★ |

Любой из представленных миксеров дает хороший лавинный эффект улучшает результат прохождения теста SMHasher.

**Выбор констант миксера**

Уменьшение коллизий основано на том что число - множитель - простое число и является генератором мультипликативной группы $Z/2^{64}Z$, т.е возведение в степень по модулю $2^{64}$ дает максимальную длину последовательности. Если рассматривать миксер, как обратимую операцию, то его логично строить с использованием сопряженных чисел $P_2 = P_1^{-1} \bmod 2^{64}$. Таблица миксеров не содержит таких сочетаний. Так что идея комбинировать простые числа и обратные - оригинальная и может использоваться для выбора множителей. Критерием выбора константы является прохождение теста [SAC](test/sac.c) и BIC. Кроме того, хорошим критерием является статистическое распределение единиц и ноликов по разрядам числа, тест `difficulty/hashrate`, который мы предлагаем использовать для оценки качества скрамблера/миксера. Тест позволяет получить статистику распределения бит по битовой сложности.

**Обратимость операции Mixer**

Операции вида $h = h \oplus (h \gg m)$ обратимы, операции с $m\geq 32$ обратны сами себе.
```c
uint64_t reverse_xor_shift(uint64_t h, unsigned int m) {
    h ^= (h >> m);
    if (2*m < 64) h ^= (h >> (2*m));
    if (4*m < 64) h ^= (h >> (4*m));
//	. . .
    return h;
}
```
Для сдвигов $m = 26...31$ достаточно двух действий. 

Таблица Обратимость xor-shift
| m  | обратная операция |
|----|----|
| 33 | `h ^= h >> 33;` (обратная себе)
| 32 | `h ^= h >> 32;` (обратная себе)
| 31 | `h ^= h >> 31; h ^= h >> 62;`
| 30 | `h ^= h >> 30; h ^= h >> 60;`
| 29 | `h ^= h >> 29; h ^= h >> 58;`
| 28 | `h ^= h >> 28; h ^= h >> 56;`
| 27 | `h ^= h >> 27; h ^= h >> 54;`
| 26 | `h ^= h >> 26; h ^= h >> 52;`

Таблица Обратных чисел для операции unMix
| Mixer	 | a | $Prime_1^{-1}$ | b | $Prime_2^{-1}$ | c |
|--------|---|----------------|---|--------|---|
|unMix_Lea 	  | |`0xa6f8e26927e132cb` | |`0xA6F8E26927E132CB` |
|unSplitMix64 | |`0x96de1b173f119089` | |`0x319642B2D24D8EC3` |
|unAvalanche  | |`0x0ba79078168d4baf` | |`0xE9E9F4C41D6DF849` |
|unMix01 | |`0x4c5ff4596f4a2f4d` | |`0x4D6DFF26C61D8485` |
|unMix02 | |`0xfaa6b01ec53551e7` | |`0x9BB5680ABE73E627` |
|unMix03 | |`0xcb94d79668acb81d` | |`0xB0E38339F3478507` |
|unMix04 | |`0x8e7fc80bbd7bbe5d` | |`0x13A10FC6E8A1817B` |
|unMix05 | |`0x4d7dac66e4190d75` | |`0xABCDFD8F7FB3248D` |
|unMix06 | |`0x7b3e9e7a952f25f9` | |`0x059575CCED6AAC45` |
|unMix07 | |`0x2047f2bc3066a28d` | |`0x74CA595AE625F12D` |
|unMix08 | |`0x294dde0da6c4a4a3` | |`0xDD04785DF6D8F6A7` |
|unMix09 | |`0x4434dd7ecb5ab665` | |`0x8BFD21AC23740E59` |
|unMix10 | |`0x49e0439cd61fd05d` | |`0x02054AEE6574CB9B` |
|unMix11 | |`0xf542db7fa2580f69` | |`0x1D16CF44AFE4F743` |
|unMix12 | |`0x66d6694153c4d533` | |`0xCE487C2C5BA60273` |
|unMix13 | |`0x96de1b173f119089` | |`0x319642B2D24D8EC3` |
|unMix14 | |`0x4ab3236cb05fc05b` | |`0xAB56D1249120401B` |

Для обращения операции умножения `*=` надо найти обратное число $B = A^{-1}$ такое, что 
```math
A\cdot B \bmod 2^{64} \equiv 1
```
Таким образом функция XMXMX- avalanche Mixer является обратимой функцией. 

## MUM - миксеры

MUM-миксер (MUltiply and Mix) - это просто операция умножения 64 x 64 бит с результатом 128 бит. 

1. $\{r_{lo}, r_{hi}\} = A\cdot B$
2. $r_{lo}\oplus r_{hi} \bmod 2^{64}$

Вместо того чтобы описывать свойства миксера я представлю класс генераторов случайных чисел. Он начинается с генератора Lehmer64 и аналогичного WYrand. 
```c
static uint128_t state=SEED;
uint64_t lehmer64() {
    state *= 0xda942042e4dd58b5ULL;   // фиксированный множитель
    return (uint64_t)(state >> 64);   // берём старшие 64 бита как результат
}
```
Множитель выбирается так, чтобы период был максимальный. Максимальный период $2^{126}$. Как выбрать подобный множитель - случайно. Случайное число должно быть  генератором мультипликативной группы и давать хороший лавинный эффект. 

* [wyhash](https://github.com/wangyi-fudan/wyhash) 
* [rapidhash](#)
```c
uint64_t seed = SEED;
uint64_t wyrand() {
    seed += UINT_64_C(0x60bee2bee120fc15);
    uint128_t y = (uint128_t)(seed) * UINT64_C(0xa3b195354a39b70d);
    return y ^ (y >> 64);
}
```
Если из операции можно сделать трансформацию для генератора с большим периодом повтора, то это хороший кандидат на изготовление генератора случайных чисел. Некоторые числа обладают свойством генератора последовательности на операции сложения, Weyl-подобные числа. Некоторые являются генератором поля $Z/2^{64}Z$ по умножению. Кроме того, от множителя требуется, чтобы он давал хороший лавинный эффект с вероятностью 50% по каждому биту. 

Возможно чуть лучше с простыми числами обстоит дело в проекте [MUM-hash](https://github.com/vnmakarov/mum-hash). Там операция `mum` использует сложение $r_{lo}\oplus r_{hi} \bmod 2^{64}$.

Мои тесты показали, что на операции MUM миксеры ведут себя лучше, чем XMXMX-миксеры. Операция MUM быстрее XMXMX. Чтобы сделать осознанный выбор мы тестировали и подбирали множители с разными Weyl-константами. 

## CRT - миксеры

Давайте представим, что умножение на большую константу является хорошим миксером. Идея CRT-миксера исходит из китайской теоремы об остатках. Пусть a1, a2 независимо посчитанные числа от входного потока данных по двум независимым модулям p1, p2. 
```c
uint128_t crt_mix(uint64_t a1, uint64_t a2) {
    const uint64_t y1 = mod_inverse(p2 % p1, p1);
    const uint64_t y2 = mod_inverse(p1 % p2, p2);
    return a1 * p2 * y1 + a2 * p1 * y2;
}
```
Подобный миксер можно использовать для увеличения разрядности MWC64, при этом два (и более) модулей могут считаться параллельно. 

* см. Residue Number System (RNS) -- система остаточных классов

## Методика тестирования

Методика тестирования включает множество тестов SMHasher, среди которых выделяются:
* `SpeedBulk` Тест скорости, показывает производительность в байтах входных данных на такт процессора.
* `SpeedSmall` Тест скорости на небольших объемах от 1 до 32 байта
* `Avalanche`/`BIC` Показательный тест насколько хорошо происходит замешивание бит, прохождение теста обеспечивается миксером. 
* `Bias` (в avalanche-отчёте) Максимальное отклонение битов от 50%, не должно превышать 0.9%

Краткие описания тестов SMHasher:

| Тест            | Краткое описание                                      |
|-----------------|-------------------------------------------------------|
| Avalanche       | лавинный эффект (1 бит изменения → ~50% битов выхода) |
| Sparse          | хеширование разреженных/почти пустых ключей           |
| Permutation     | тесты на перестановки ключей                          |
| Window          | скользящее окно по большим ключам                     |
| Cyclic          | периодические/циклические данные                      |
| TwoBytes        | полный перебор всех 2-байтовых ключей                 |
| Text            | тесты на текстовых строках/паттернах                  |
| Zeroes          | ключи из нулей (начало/конец/все нули)                |
| Seed            | поведение при разных seed-ах                          |
| PerlinNoise     | хеширование шума Перлина (плавные градиенты)          |
| Diff            | дифференциальные тесты (малые изменения)              |
| DiffDist        | распределение дифференциалов                          |
| BIC             | Bit Independence Criterion (независимость битов)      |
| MomentChi2      | хи-квадрат по моментам распределения                  |
| Prng            | хеш как генератор псевдослучайных чисел               |
| BadSeeds        | поиск плохих/слабых seed-ов                           |

Наиболее значимые тесты и условия прохождения - Все тесты! Мы не используем в проектах хэш функции, которые не проходят все эти тесты. Заметим, что к хэш функциям для хэш-таблиц не предъявляется требование отсутствия коллизий. Наиболее чувстивтельные тесты к функции Avalanche minxer - `Avalanche`,`DiffDist`,`Sparse`. Ряд тестов выявляют коллизии в битах и перестановках. Некоторые тесты, такие  как `TwoBytes` чувствительны к финализации хэш-функции на невыровненных данных. 

`MomentChi2` единственный статистический тест в наборе, по которому выполнялось сравнение. Правильно подобранная константа генератора обеспечивает уровень прохождения `Great` и значения близкие к единице. 

Функция генератора MWC с выбранным параметром должна проходить тест Crush TestU01 в качестве генератора ГПСЧ. И тест HWD, Hamming-Weight Dependencies, который обеспечивает тестирование паттернами на больших выборках порядка $10^{13}$. Дополнительно должны запускаться тесты `Linear-complexity` по каждому биту и `Matrix-Runk` на существенно больших выборках.
Подобный подход в тестировании использован для LXM генератора. 

## Результаты работы

Алгоритмы некриптографического хэша:
* Модель обратимого хэш c skip/merge на базе MWC64-hash
* [MWC64-hash](test/mwc64_hash.c) с размером выхода 64 бита, состояние 64 бита.
* [MWC128-hash](test/mwc128_hash.c) с размером выходных данных 128 и 64 бита. 
* [MWC192-hash](test/mwc192_hash.c) с размером выходных данных 192, 128 и 64 бита. 
* [Xoroshiro128-hash](test/xoshiro_hash.c) с длиной хеша 64 бита. Три варианта генератора с разным набором сдвиговых констант.
* [xxHash64](test/xxh64.c) с длиной хеша 64 бита, переносимая реализация с явной векторизацией.


**Speed Test**

Сервер Intel Xeon E5-2673 v4 Micro-architecture: Broadwell

| hash  | bytes/cycle | Скорость |
|-------|-------------------|----------------------------|
| [mwc128](test/test-mwc128-64-smhasher.txt)| 2.330  	  | 5098.79 MiB/sec @ 2295 MHz |
| mwc192 | 3.741 | 8188.38 MiB/sec @ 2295 MHz
| xxh64  | 2.380       | 5209.48 MiB/sec @ 2295 MHz |
| xoroshiro | 0.356 | 778.59 MiB/sec @ 2295 MHz |

Тест `SpeedBulk` выполняется на блоках 256k и это может быть не показательно, когда хеши изготавливаются для коротких строк. 

Тест `SpeedSmall` позволяет сравнить производительность на коротких строках, 8-16-32 байта (с выравниванием) и без выравнивания 1-32 байта, 
На x86_64 MWC128 хэш выигрывает в производительности.



Одноплатный компьютер ARM AArch64 Cortex-A55:

| hash  | bytes/cycle | Скорость |
|-------|-------------------|----------------------------|
| xxh64  | 0.741 | 1086.17 MiB/sec @ 1536 MHz
| mwc128 | 0.571 |  836.48 MiB/sec @ 1536 MHz
| xoroshiro | 0.175 | 256.95 MiB/sec @ 1536 MHz


**Результаты теста SMHasher** 
* [mwc128-64-hash-smhasher](test/test-mwc128-64-smhasher.txt) MWC128 с размером хэщ 64 бит
* [mwc128-128-hash-smhasher](test/test-mwc128-128-smhasher.txt) MWC128 с размером хэш 128 бит
* [xoroshiro128-hash-smhasher](test/test-xoroshiro128-smhasher.txt)
* [xxh64-hash-smhasher](test/test-xxh64-smhasher.txt)

Параметры генератора и миксера подлежат оптимизации, константы не рассчитывались, а заимствованы из других работ. 

Дальнейшее развитие темы: оптимизация параметров, генератор с запаздыванием MWC64v2, генератор использующий вектор из генераторов MWC, и векторный алгоритм параллельной генерации хэш.

**Векторные расширения**

Для обработки больших массивов данных (в том числе тензоров) перспективно развивать векторные варианты генератора: параллельное обновление нескольких 128-битных состояний с обменом carry между ними с применением перестановок/матричных миксов на уровне 4 слов (аналогично тому, как это делается в расширениях xoshiro256/512). Такие подходы позволяют сохранить обратимость и возможность skip/merge, одновременно повышая пропускную способность на SIMD-архитектурах.

[больше тестов SMHasher](https://rurban.github.io/smhasher/)

[SMHasher3](https://gitlab.com/fwojcik/smhasher3) -- Существенно улучшено быстродействие, улучшено тестирование, более строгие политики. Внесены существенные доработки тестов. 

* [MWC128-hash для теста SMHasher](test/mwc128_hash.cpp) 
* результаты [MWC128-64 = 188/188 passed](test/mwc128-64-smhasher3.txt)


[1] David Blackman and Sebastiano Vigna. 2018. Scrambled Linear Pseudorandom Number Generators. \
3 May 2018, 41 pages. [arxiv:1805.01407]() To appear in ACM Transactions on Mathematical Software.

[2] Austin Appleby. 2016. SMHasher. 8 Jan. 2016, https://github.com/aappleby/smhasher

[3] Richard P. Brent. 2004. Note on Marsaglia’s Xorshift Random Number Generators.\
Journal of Statistical Software, 11, 5, Aug., 1–5. coden:JSSOBK (https://doi.org/10.18637/jss.v011.i05)

[4] Guy L. Steele Jr. and Sebastiano Vigna. 2021. LXM: better splittable pseudorandom number generators (and almost as fast). 
Proc. ACM Program. Lang. 5, OOPSLA, Article 148 (October 2021), 31 pages. (https://doi.org/10.1145/3485525)

(https://gitlab.com/fwojcik/smhasher3)


**Сборка теста**


```sh
$ git clone https://github.com/rurban/smhasher.git
$ cd smhasher
$ git submodule update --init --recursive
$ cmake -B build
$ cmake --build build -j 16 
; Если всё хорошо собралось, можно прогнать тесты для встроенной функции, их там много:
$ ./build/SMHasher prvhash64_64
```
Таблица тестов хэш-функций добавляется в `main.cpp`
```cpp
{ xoroshiro_test, 64, 0xA8F45CF8, "xoroshiro",   "xoroshiro128_hash"},
{ mwc64_test,     64, 0xA8F45CF8, "mwc64",       "mwc64_hash"	    },
{ mwc128_test,    64, 0x6ED613CD, "mwc128",      "mwc128-64_hash"   },
{ mwc192_test,   128, 0xC1D62836, "mwc192",  	 "mwc192-128_hash"  },
{ xxh64_test,     64, 0xA8F45CF8, "xxh64",       "xxh64_hash"       },
```

```sh
$ ./build/SMHasher mwc128
$ ./build/SMHasher mwc192
$ ./build/SMHasher xxh64
$ ./build/SMHasher xoroshiro
```
