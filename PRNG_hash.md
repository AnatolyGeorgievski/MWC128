# Хэш функция на базе генератора случайных чисел

 * _Анатолий М. Георгиевский_ , ИТМО, 2026 (https://github.com/AnatolyGeorgievski)
 * _ĀĿΞX_ (https://github.com/Alex20129), -- обсуждение принципов построения mwc-хэш и тестирование 

> Представляем метод синтеза некриптографической хэш-функции на алгоритмах MWC128.

Известно множество некриптографических функций, которые могут быть использованы для индексации баз данных и проверки контрольных сумм массивов данных. К таким функция предъявляются требования - низкая вероятность коллизий. Традиционно эта ниша занята алгоритмами CRC64. Линейное преобразование LCG или CRC не избавляет от коллизий. В сетевых протоколах и архиваторах используются различные функции среди, которых выделяется xxHash64 (Yann Collet). Интересует быстродействие хэш-функции на потоке данных, возможность считать параллельно с разбивкой данных на сегменты и векторизовать вычисления.

Современные хэш-функции строятся по принципу SPONGE-SQUEEZE: состоят из цикла впитывания данных и отжимания "губки". 

1. Линейный генератор с возможностью выполнять skip и jump на потоке данных.
2. Функция пермутации-миксер выходных данных.

Тестирование хэш-функций выполняется в пакете [SMHasher](https://github.com/aappleby/smhasher). Тесты ориентированы на выявление слабых бит в хэше и поиск коллизий.

В данной работе мы ссылаемся на опыт разработки LXM генератора [4], где авторы использовали множество типовых миксеров для придания функции генератора ГПСЧ необходимого качества, для прохождения тестов без коллизий.

В ходе разработки алгоритма мы повторили результаты [4] с использованием генератора `Xoroshiro128p` И миксера выходных значений предложенного авторами в работе. Кроме того протестировали ряд других миксеров. Исходный код подготовлен для теста SMHasher см. [xoroshiro-hash](test/xoshiro_hash.c). Для сравнения реализовали собственную версию функции xxHash64. 


**Алгоритм MWC128-hash**

```c
uint64_t mwc128_hash(const uint8_t *data, uint64_t len, uint64_t seed0) {
	uint128_t h;
	uint64_t* s = (uint64_t*)&h;
	for (int i=0;i<2;i++)
		s[i] = unmix(seed+=IV);
	for (int i=0; i<len>>3; i++){
		h+=*(uint64_t*)data; data+=8;
		h = (uint64_t )h*A1 + (h>>64); // итерация MWC128
	}
	if (len&7) {
		int r = len&7;// reminder
		uint64_t d = PAD;
		memcpy(&d, data, r); data+=r;
		h+= (d);
		h = (uint64_t )h*(A1<<(64-(r*8))) + (h>>(r*8));
	}
	return mix(h^(h>>64));
}
```
Параметры алгоритма: 
* `A1` - параметр генератора MWC128, где $P=A_1\cdot 2^{64} -1$ простое число.
* `IV` - вектор инициализации хэш
* `PAD` - дополнение данных `0x0102030405060708`

В составе алгоритма использован миксер Doug Lea's. Это не самый сильный миксер, но самый простой и оптимально подошел к нашей задаче. 
```c
// Doug Lea's MXMX- mixing function
static inline uint64_t mix_lea(uint64_t h) {
  h ^= h >> 32;
  h *= 0xdaba0b6eb09322e3ull;
  h ^= h >> 32;
  h *= 0xdaba0b6eb09322e3ull;
  h ^= h >> 32;
  return h;
}
```
Ниже мы приводим множество миксеров, с которыми можно комбинировать выход функции генератора.

**Алгоритм PRNG-hash**

Алгоритм построен на генераторе Xoroshiro128, как в работе [4], LXM. Применяется рандомизация и миксер выходных значений. В качестве миксера выбрана функция `mix_lea()`, Doug Lea's mixing function. 
Для построения хэш функции использован генератор `Xoroshiro128+`, выходным значением генератора является `plus` скрамблер от внутреннего состояния.
```c
uint64_t xoroshiro_hash(const uint8_t *data, uint64_t len, uint64_t seed) {
	uint64_t s[STATE_SZ];
	for (int i=0; i<STATE_SZ; i++)
		s[i] = unmix_lea(seed+=IV);
	for (int i=0; i<len; i++) {
		s[0] ^= *data++;
		xoroshiro128_next(s);
	}
 	return mix_lea(s[0]+s[1]);
}
```

Функция миксера, как и функция генератора - обратима. Это свойство может быть использовано при контроле целостности в операции дописывания данных в конец файла.

Генераторы xoroshiro128, 
```c
static inline void xoroshiro128_next(uint64_t* s) {
	uint64_t s0 = s[0];
	uint64_t s1 = s[1];
	s1 ^= s0;
    s0 = rotl(s0, A);
	s[0] = s0 ^ s1 ^ (s1 << B);
	s[1] = rotl(s1, C);
}
```
Известные константы сдвигов сведены в таблицу. В исходном коде определены три функции xoroshiro с состоянием 128 бит.

**Mixer parameters**

Отправной точкой исследования является вариант финального миксера из функции `MurmurHash3`. Кроме того в составе разных хэш-функций мы нашли много вариантов миксера

1. $x ←  x \oplus (x \gg a)$
2. $x ←  x \cdot Prime_1$
3. $x ←  x \oplus (x \gg b)$
4. $x ←  x \cdot Prime_2$
5. $x ←  x \oplus (x \gg c)$

Подобный миксер `Doug Lea's` использован в работе [4], `SplitMix64`  предлагается авторами в качестве рандомизатора SEED при инициализации `Xoroshiro128` и генераторов с большой разрядностью состояния. `Avalanche` миксер заимствован из функции `xxHash64`.

MurmurHash3 64-bit avalanche mixer представлен в проекте SMHasher, Appleby 2016. 

| Mixer	      | a | Prime1 | b | Prime2 | c |
|-------------|---|--------|---|--------|---|
| MurmurHash3 |33 |0xff51afd7ed558ccd |33 |0xc4ceb9fe1a85ec53	|33 |
| Doug Lea's  |32 |0xdaba0b6eb09322e3 |32 |0xdaba0b6eb09322e3	|32 |
| SplitMix64  |30 |0xbf58476d1ce4e5b9 |27 |0x94d049bb133111eb   |31 |
| Avalanche   |33 |0xC2B2AE3D27D4EB4F |29 |0x165667B19E3779F9   |32 |

[David Stafford's improved mixing functions](http://zimbry.blogspot.com/2011/09/better-bit-mixing-improving-on.html) опубликованы в блоге автора.

Теблица David Stafford's Mixer 
| Mixer	| a | Prime1 | b | Prime2 | c |
|-------|---|--------|---|--------|---|
|Mix01	|31	|0x7fb5d329728ea185	|27	|0x81dadef4bc2dd44d	|33
|Mix02	|33	|0x64dd81482cbd31d7	|31	|0xe36aa5c613612997	|31
|Mix03	|31	|0x99bcf6822b23ca35	|30	|0x14020a57acced8b7	|33
|Mix04	|33	|0x62a9d9ed799705f5	|28	|0xcb24d0a5c88c35b3	|32
|Mix05	|31	|0x79c135c1674b9add	|29	|0x54c77c86f6913e45	|30
|Mix06	|31	|0x69b0bc90bd9a8c49	|27	|0x3d5e661a2a77868d	|30
|Mix07	|30	|0x16a6ac37883af045	|26	|0xcc9c31a4274686a5	|32
|Mix08	|30	|0x294aa62849912f0b	|28	|0x0a9ba9c8a5b15117	|31
|Mix09	|32	|0x4cd6944c5cc20b6d	|29	|0xfc12c5b19d3259e9	|32
|Mix10	|30	|0xe4c7e495f4c683f5	|32	|0xfda871baea35a293	|33
|Mix11	|27	|0x97d461a8b11570d9	|28	|0x02271eb7c6c4cd6b	|32
|Mix12	|29	|0x3cd0eb9d47532dfb	|26	|0x63660277528772bb	|33
|Mix13	|30	|0xbf58476d1ce4e5b9	|27	|0x94d049bb133111eb	|31
|Mix14	|30	|0x4be98134a5976fd3	|29	|0x3bc0993a5ad19a13	|31

Любой из представленных миксеров дает хороший результат прохождения теста SMHasher

**Обратимость операции Mixer**

Операции вида $h = h \oplus (h \gg m)$ обратимы, операции с $m\geq 32$ обратны сами себе.
```c
uint64_t reverse_xor_shift(uint64_t h, unsigned int m) {
    h ^= (h >> m);
    if (2*m < 64) h ^= (h >> (2*m));
    if (4*m < 64) h ^= (h >> (4*m));
//	. . .
    return h;
}
```
Для сдвигов $m = 26...31$ достаточно двух действий. 

Таблица Обратимость xor-shift
| m  | обратная операция |
|----|----|
| 33 | `h ^= h >> 33;` (обратная себе)
| 32 | `h ^= h >> 32;` (обратная себе)
| 31 | `h ^= h >> 31; h ^= h >> 62;`
| 30 | `h ^= h >> 30; h ^= h >> 60;`
| 29 | `h ^= h >> 29; h ^= h >> 58;`
| 28 | `h ^= h >> 28; h ^= h >> 56;`
| 27 | `h ^= h >> 27; h ^= h >> 54;`
| 26 | `h ^= h >> 26; h ^= h >> 52;`

Таблица Обратных чисел для операции unMix
| Mixer	 | a | $Prime_1^{-1}$ | b | $Prime_2^{-1}$ | c |
|--------|---|----------------|---|--------|---|
|unMix_Lea 	  | |`0xa6f8e26927e132cb` | |`0xA6F8E26927E132CB` |
|unSplitMix64 | |`0x96de1b173f119089` | |`0x319642B2D24D8EC3` |
|unAvalanche  | |`0x0ba79078168d4baf` | |`0xE9E9F4C41D6DF849` |
|unMix01 | |`0x4c5ff4596f4a2f4d` | |`0x4D6DFF26C61D8485` |
|unMix02 | |`0xfaa6b01ec53551e7` | |`0x9BB5680ABE73E627` |
|unMix03 | |`0xcb94d79668acb81d` | |`0xB0E38339F3478507` |
|unMix04 | |`0x8e7fc80bbd7bbe5d` | |`0x13A10FC6E8A1817B` |
|unMix05 | |`0x4d7dac66e4190d75` | |`0xABCDFD8F7FB3248D` |
|unMix06 | |`0x7b3e9e7a952f25f9` | |`0x059575CCED6AAC45` |
|unMix07 | |`0x2047f2bc3066a28d` | |`0x74CA595AE625F12D` |
|unMix08 | |`0x294dde0da6c4a4a3` | |`0xDD04785DF6D8F6A7` |
|unMix09 | |`0x4434dd7ecb5ab665` | |`0x8BFD21AC23740E59` |
|unMix10 | |`0x49e0439cd61fd05d` | |`0x02054AEE6574CB9B` |
|unMix11 | |`0xf542db7fa2580f69` | |`0x1D16CF44AFE4F743` |
|unMix12 | |`0x66d6694153c4d533` | |`0xCE487C2C5BA60273` |
|unMix13 | |`0x96de1b173f119089` | |`0x319642B2D24D8EC3` |
|unMix14 | |`0x4ab3236cb05fc05b` | |`0xAB56D1249120401B` |

Для обращения операции умножения `*=` надо найти обратное число $B = A^{-1}$ такое, что 
```math
A\cdot B \bmod 2^{64} \equiv 1
```
Таким образом функция XMXMX- avalanche Mixer является обратимой функцией. 


## Методика тестирования

Методика тестирования включает множество тестов, среди которых выделяются:
* `SpeedBulk` Тест скорости, показывает производительность в байтах входных данных на такт процессора.
* `SpeedSmall` Тест скорости на небольших объемах от 1 до 32 байта
* `Avalanche` Показательный тест насколько хорошо происходит замешивание бит, прохождение теста обеспечивается миксером. 
* `Bias` (в avalanche-отчёте) Максимальное отклонение битов от 50%, не должно превышать 0.9%

Краткие описания тестов SMHasher:

| Тест            | Краткое описание                                      |
|-----------------|-------------------------------------------------------|
| Avalanche       | лавинный эффект (1 бит изменения → ~50% битов выхода) |
| Sparse          | хеширование разреженных/почти пустых ключей           |
| Permutation     | тесты на перестановки ключей                          |
| Window          | скользящее окно по большим ключам                     |
| Cyclic          | периодические/циклические данные                      |
| TwoBytes        | полный перебор всех 2-байтовых ключей                 |
| Text            | тесты на текстовых строках/паттернах                  |
| Zeroes          | ключи из нулей (начало/конец/все нули)                |
| Seed            | поведение при разных seed-ах                          |
| PerlinNoise     | хеширование шума Перлина (плавные градиенты)          |
| Diff            | дифференциальные тесты (малые изменения)              |
| DiffDist        | распределение дифференциалов                          |
| BIC             | Bit Independence Criterion (независимость битов)      |
| MomentChi2      | хи-квадрат по моментам распределения                  |
| Prng            | хеш как генератор псевдослучайных чисел               |
| BadSeeds        | поиск плохих/слабых seed-ов                           |

Наиболее значимые тесты и условия прохождения - Все тесты! Мы не используем в проектах хэш функции, которые не проходят все эти тесты. Заметим, что к хэш функциям для хэш-таблиц не предъявляется требование отсутствия коллизий. Наиболее чувстивтельные тесты к функции Avalanche minxer - `Avalanche`,`DiffDist`,`Sparse`. Ряд тестов выявляют коллизии в битах и перестановках. Некоторые тесты, такие  как `TwoBytes` чувствительны к финализации хэш-функции на невыровненных данных. 

`MomentChi2` единственный статистический тест в наборе, по которому выполнялось сравнение.

Дополнительно хэш-функция MWC с выбранным миксером в режиме XOF генерации должна проходить тест Crush в качестве генератора ГПСЧ. И тест HWD, Hamming-Weight Dependencies, который обеспечивает тестирование паттернами на больших выборках порядка $10^{13}$. Подобный подход в тестировании использован для LXM генератора.

Режим XOF генерации обеспечивается циклом

```c
_next(s);
return mix(s[0]^s[1]);
```
Этот метод мы использовали в функции `mwc128_128`.

## Результаты работы

Алгоритмы некриптографического хэша:
* [MWC128-hash](test/mwc128_hash.c) с размером выходных данных 128 и 64 бита. 
* [MWC192-hash](test/mwc192_hash.c) с размером выходных данных 192, 128 и 64 бита. 
* [Xoroshiro128-hash](test/xoshiro_hash.c) с длиной хеша 64 бита. Три варианта генератора с разным набором сдвиговых констант.
* [xxHash64](test/xxh64.c) с длиной хеша 64 бита, переносимая реализация с явной векторизацией.

**Speed Test**

Сервер Intel Xeon E5-2673 v4 Micro-architecture: Broadwell

| hash  | bytes/cycle | Скорость |
|-------|-------------------|----------------------------|
| [mwc128](test/test-mwc128-64-smhasher.txt)| 2.330  	  | 5098.79 MiB/sec @ 2295 MHz |
| mwc192 | 3.741 | 8188.38 MiB/sec @ 2295 MHz
| xxh64  | 2.380       | 5209.48 MiB/sec @ 2295 MHz |
| xoroshiro | 0.356 | 778.59 MiB/sec @ 2295 MHz |

Тест `SpeedBulk` выполняется на блоках 256k и это может быть не показательно, когда хеши изготавливаются для коротких строк. 

Тест `SpeedSmall` позволяет сравнить производительность строках, 8-16-32 байта (с выравниванием) и без выравнивания 1-32 байта, 
На x86_64 MWC128 хэш выигрывает в производительности.



Одноплатный компьютер ARM AArch64 Cortex-A55:

| hash  | bytes/cycle | Скорость |
|-------|-------------------|----------------------------|
| xxh64  | 0.741 | 1086.17 MiB/sec @ 1536 MHz
| mwc128 | 0.571 |  836.48 MiB/sec @ 1536 MHz
| xoroshiro | 0.175 | 256.95 MiB/sec @ 1536 MHz


**Результаты теста SMHasher** 
* [mwc128-64-hash-smhasher](test/test-mwc128-64-smhasher.txt) MWC128 с размером хэщ 64 бит
* [mwc128-128-hash-smhasher](test/test-mwc128-128-smhasher.txt) MWC128 с размером хэш 128 бит
* [xoroshiro128-hash-smhasher](test/test-xoroshiro128-smhasher.txt)
* [xxh64-hash-smhasher](test/test-xxh64-smhasher.txt)

Параметры генератора и миксера подлежат оптимизации, константы не рассчитывались, а заимствованы из других работ. 

Дальнейшее развитие темы: оптимизация параметров, генератор MWC64r2, использующий вектор из генераторов MWC, и векторный алгоритм параллельной генерации хэш.

[больше тестов SMHasher](https://rurban.github.io/smhasher/)


[1] David Blackman and Sebastiano Vigna. 2018. Scrambled Linear Pseudorandom Number Generators. \
3 May 2018, 41 pages. [arxiv:1805.01407]() To appear in ACM Transactions on Mathematical Software.

[2] Austin Appleby. 2016. SMHasher. 8 Jan. 2016, https://github.com/aappleby/smhasher

[3] Richard P. Brent. 2004. Note on Marsaglia’s Xorshift Random Number Generators.\
Journal of Statistical Software, 11, 5, Aug., 1–5. coden:JSSOBK (https://doi.org/10.18637/jss.v011.i05)

[4] Guy L. Steele Jr. and Sebastiano Vigna. 2021. LXM: better splittable pseudorandom number generators (and almost as fast). 
Proc. ACM Program. Lang. 5, OOPSLA, Article 148 (October 2021), 31 pages. (https://doi.org/10.1145/3485525)


**Сборка теста**


```sh
$ git clone https://github.com/rurban/smhasher.git
$ cd smhasher
$ git submodule update --init --recursive
$ cmake -B build
$ cmake --build build -j 16 
; Если всё хорошо собралось, можно прогнать тесты для встроенной функции, их там много:
$ ./build/SMHasher prvhash64_64
```
Таблица тестов хэш-функций добавляется в `main.cpp`
```cpp
{ xoroshiro_test, 64, 0xA8F45CF8, "xoroshiro",   "xoroshiro128_hash"},
{ mwc64_test,     64, 0xA8F45CF8, "mwc64",       "mwc64_hash"	    },
{ mwc128_test,    64, 0x6ED613CD, "mwc128",      "mwc128-64_hash"   },
{ mwc192_test,   128, 0xC1D62836, "mwc192",  	 "mwc192-128_hash"  },
{ xxh64_test,     64, 0xA8F45CF8, "xxh64",       "xxh64_hash"       },
```

```sh
$ ./build/SMHasher mwc128
$ ./build/SMHasher mwc192
$ ./build/SMHasher xxh64
$ ./build/SMHasher xoroshiro
```
